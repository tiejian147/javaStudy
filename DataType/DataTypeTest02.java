/*
    关于java语言当中的整数型：
        数据类型          占用空间大小        默认值       取值范围
        -------------------------------------------------------------------
        byte                1               0           [-128~127]
        short               2               0           [-32768~32767]
        int                 4               0           [-2147483648~2147483647]
        long                8               0L
    
    1、java语言当中的整数型字面值被默认当做int类型来处理，要让这个整数型字面值被当做long类型来处理的话，需要在整数型字面值
    后面加1/L，建议用大写的L。

    2、java语言当中的整数型字面值有三种表达方式；
        第一种方式：十进制【是一种缺省默认的方式】常用；
        第二种方式：八进制【在编写八进制整数型默认值的时候需要在前面加0】
        第三种方式：十六进制【在编写十六进制整数型默认值的时候需要在前面加0x】


*/

public class DataTypeTest02{
    public static void main(String[] args){
        
        //声明一个变量a，并赋值
        int a = 10;
        
        //声明一个变量b,并赋值
        int b = 010;

        //声明一个变量c，并赋值
        int c = 0x10;


        //打印以上变量
        System.out.println(a); //这里打印的是十进制：10

        System.out.println(b);//这里打印的是八进制：8

        System.out.println(c);//这里打印的是十六进制：16

        System.out.println(a + b + c);  // 34

        //456整数型字面值被当做int类型，占用4个字节；
        //x变量在声明的时候是long类型，占用8个字节；
        //int类型的字面值456赋值给long类型的变量x，存在类型转换
        //int类型转换成long类型
        //int类型是小容量
        //long类型是大容量
        //小容量可以自动转换为大容量，称为自动类型转换机制；
        long x =456;

        System.out.println(x);//这里打印没有问题；

        //编译错误：过大的整数；
        //2147483648 被当做int类型4个字节处理，但是这个字面值超出了int类型的范围
        //long y = 2147483648;
        //System.out.println(x);

        //解决错误；
        //2147483648 字面值一上来就当做long类型来出来就不会报错了，在字面值后面加L
        //2147483648L是个8字节的long类型
        //z是long类型变量，以下程序不存在类型转换；
        long z = 2147483648L;
        System.out.println(z);//此时打印成功；

        //100L是long类型字面值；
        //m是long类型，所以不存在类型转换，直接赋值；
        long m = 100L;

        //m是大容量类型long类型，8个字节；n是小容量类型int类型，4个字节；
        //以下程序就会在编译时报错：大容量不能直接给小容量赋值；
        // int n = m;
        // System.out.println(n);

        //大容量类型转换为小容量类型，需要进行强制类型转换；强制类型转换需要加“强制类型转换符”
        //加上强制类型转换符之后，编译通过了，但是编译过程当中可能会损失精度；
        //所以强制类型转换需谨慎使用，因为精度损失后，后果可能会很严重；
        //强转原理：
            //原始数据： 00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
            //强转后的数据：00000000 00000000 00000000 01100100
            //将左边的二进制都砍掉了【所有的数据强转的时候都是这样完成的】
            int n = (int) m;
            System.out.println(n);//这里的打印结果，精度表面上看没有损失；

        //以下程序为反例：
        //强转之前的数据为：00000000 00000000 00000000 00000000 10000000 00000000 00000000 00000000
        //强转之后的数据为：10000000 00000000 00000000 00000000
        //10000000 00000000 00000000 00000000 目前存储在电脑内部，计算机存储数据都是单用补码的性质存储的
        //所以10000000 00000000 00000000 00000000 现在是一个补码形式
        //将以上的补码转换到原码就是最终的结果；
        long k =2147483648L;
        int p = (int)k;
        System.out.println(p);//这里的打印结果精度损失严重，结果是负数 [-2147483648]

        //分析以下的程序是否编译通过？
        //依据目前所学知识，以下程序是无法编译通过的；
        //理由：10 是int类型的字面值，s 是byte类型的赋值变量，显然是大容量int转换成小容量的byte
        //大容量转换成小容量是需要添加强制转换符的，以下程序没有添加强转符号，所以应该编译报错；
        //但是在实际编译的过程中，以下代码编译通过了，这说明：在java语言当中，当一个整数型字面值没有超出byte类型取值范围的话，该字面值可以直接赋值给byte类型的变量；
        byte s = 10;// 可以编译

        System.out.println(s);//打印成功且正确；

        byte g = 127;//可以编译

        System.out.println(g);//打印成功且正确；

        // byte d =  128; // 编译报错：128这个int类型的字面值已经超出了byte类型的取值范围，不能直接赋值给byte类型的变量；

        //纠正错误，需要使用强制类型转换符，但是一定会损失精度；
        //原始数据：00000000 00000000 00000000 10000000
        //强转之后：10000000 【这是存储在计算机内部的，这是一个补码，它的原码是什么？去百度】
        byte d = (byte)128;

        System.out.println("这里的值是：" + d);//强转之后损失精度严重：【-128】


        short a1 =32767;//编译通过
        System.out.println(a1);//打印成功且正确；
        //a1 = 32768; //编译报错；

        char cc =65535;  //编译通过
        //cc =65536;  //编译报错；
        System.out.println("这是什么情况" + cc);

        /*
            总结：
            当一个整数字面值没有超出byte,short,char的取值范围，这个字面值可以直接赋值给byte，short,char 类型的变量。
            这种机制SUN公司允许，目的是为了方便程序员的编程；
        */

        









    }
}